# 算法题

### 数据结构

#### 剑指 Offer 05. 替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

```java
class Solution{
  public String replaceSpace(String s){
    char[] sCs = s.toCharArray();
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < sCs.legnth; i++){
      if (sCs[i] == ' '){
        sb.append("%20");
      }else{
        sb.append(sCs[i]);
      }
    }
    return sb.toString();
  }
}
```



#### 剑指 Offer 06. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

```
输入：head = [1,3,2]
输出：[2,3,1]
```

```java
class Solution{
  public int[] reversePrint(ListNode head){
    if (head == null){
      return new int[0];
    }
    Stack<Integer> stack = new Stack<>();
    while (head != null){
      stack.push(head.val);
      head = head.next;
    }
    int length = stack.size;
    int[] res = new int[length];
    for (int i = 0; i < length; i++){
      res[i] = stack.pop();
    }
    return res;
  }
}
```



#### 剑指 Offer 09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

示例 1：

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

示例 2：

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

```java
class CQueue{
  Stack<Integer> stack1;
  Stack<Integer> stack2;
  
  public CQueue(){
    stack1 = new Stack<>();
    stack2 = new Stack<>();
  }
  
  public void appendTail(int value){
    stack1.push(value);
  }
  
  public int deleteHead(){
    if (!stack2.isEmpty()){
      return stack2.pop();
    }else if (stack1.isEmpty()){
      return -1;
    }
    while (!stack1.isEmpty()){
      stack2.push(stack1.pop());
    }
    return stack2.pop();
  }
}
```



##### 剑指 Offer 20. 表示数值的字符串
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。

数值（按顺序）可以分成以下几个部分：

1. 若干空格
2. 一个 小数 或者 整数
3. （可选）一个 'e' 或 'E' ，后面跟着一个 整数
4. 若干空格小数（按顺序）可以分成以下几个部分：


示例 1：

```
输入：s = "0"
输出：true
```

示例 2：

```
输入：s = "e"
输出：false
```

示例 3：

```
输入：s = "."
输出：false
```

示例 4：

```
输入：s = "    .1  "
输出：true
```

```java
class Solution{
	public boolean isNumber(String s){
    char[] sCs = s.trim().toCharArray();
    int length = sCs.length;
    boolean isNum = false, isDot = false, iseOrE = false;
    for (int i = 0; i < length; i++){
      char c = sCs[i];
      if (c >= '0' && c <= '9'){
        isNum = true;
      }else if (c == '.'){
        if (iseOrE || isDot){
          return false;
        }
        idDot = true;
      }else if (c == 'e' || c == 'E'){
        if (iseOrE || !isNum){
          return false;
        }
        isNum = false;
        iseOrE = true;
      }else if (c == '+' || c == '-'){
        if (i != 0 && sCs[i - 1] != 'E' && sCs[i - 1] != 'e'){
          return false;
        }
      }else {return false;}
    }
    return isNum;
  }
}
```



#### 剑指 Offer 24. 反转链表
定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

```java
class Solution{
	public ListNode reverseList(ListNode head){
    if (head == null || head.next == null){
      return head;
    }
    ListNode temp = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return temp;
  }
}
```



#### 剑指 Offer 30. 包含 min 函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

示例:

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

```java
class MinStack{
  Stack<Integer> stack1;
  Stack<Integer> stack2;
  
  public MinStack(){
    stack1 = new Stack<>();
    stack2 = new Stack<>();
  }
  
  public void push(int x){
    stack1.push(x);
    if (stack2.isEmpty() || stack2.peek() >= x){
      stack2.push(x);
    }
  }
  
  public void pop(){
    if (stack2.peek().equals(stack1.peek())){
      stack2.pop();
    }
    stack1.pop();
  }
  
  public int top(){
    return stack1.peek();
  }
  
  public int min(){
    return stack2.peek();
  }
}
```



#### 剑指 Offer 35. 复杂链表的复制
请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

```java
class Solution{
  public Node copyRandomList(Node head){
    Node cur = head;
    Map<Node, Node> map = new HashMap<>();
    if (head == null){
      return null;
    }
    while (cur != null){
      map.put(cur, new Node(cur,val));
      cur = cur.next;
    }
    cur = head;
    while (cur != null){
      map.get(cur).next = map.get(cur.next);
      map.get(cur).random = map.get(cur.random);
      cur = cur.next;
    }
    return map.get(head);
  }
}
```



#### 剑指 Offer 58 - II. 左旋转字符串
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。 

示例 1：

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

示例 2：

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

```java
class Solution{
  public String reverseLeftWords(String s, int n){
    char[] sCs = s.toCharArray();
    StringBuilder sb = new StringBuilder();
    for (int i = n; i < sCs.length; i++){
      sb.append(sCs[i]);
    }
    for (int i = 0; i < n; i++){
      sb.append(sCs[i]);
    }
    return sb.toString();
  }
}
```



#### 剑指 Offer 59 - I. 滑动窗口的最大值

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

示例:

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值

---------------               -----

[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```



#### 剑指 Offer 59 - II. 队列的最大值
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

示例 2：

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

```java
class MaxQueue{
  Queue<Integer> queue;
  Deque<Integer> deque;
  
  public MaxQueue(){
    queue = new LinkedList<>();
    deque = new LinkedList<>();
  }
  
  public int max_value(){
    return deque.isEmpty() ? -1 : deque.peekFirst();
  }
  
  public void push_back(int value){
    queue.offer(value);
    while (!deque.isEmpty() && deque.peekLast() < value){
      deque.pollLast();
    }
    deque.offer(value);
  }
  
  public int pop_front(){
    if (queue.isEmpty()){
      return -1;
    }
    if (queue.peek().equals(deque.peekFirst())){
      deque.pollFirst();
    }
    return queue.poll();
  }
}
```



#### 剑指 Offer 67. 把字符串转换成整数

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

```java
class Solution{
  public int strToInt(String str){
    int length = str.length;
    if (length == 0){
      return 0;
    }
    char[] strCs = str.toCharArray();
    int ans = 0;
    int sign = 1;
    int i = 0;
    while (strCs[i] == ' '){
      if (++i == length){
        return 0;
      }
    }
    if (strCs[i] == '-'){
      sign = -1;
    }
    if (strCs[i] == '-' || strCs[i] == '+'){
      i++;
    }
    while (i < length){
      if (strCs[i] < '0' || strCs[i] > '9'){
        return sign * ans;
      }else if (ans > Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 && strCs[i] - '0' > Integer.MAX_VALUE % 10)){
        return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
      }
      ans = ans * 10 + (strCs[i] - '0');
      i++
    }
    return sign * ans;
  }
}
```



### 动态规划

#### 剑指 Offer 10- I. 斐波那契数列
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

```
输入：n = 2
输出：1
```

示例 2：

```
输入：n = 5
输出：5
```

```java
class Solution{
  public int fib(int n){
    if (n < 2){
      return n;
    }
    int first = 0, second = 1, res = 0;
    for (int i = 1; i < n; i++){
      res = (first + second) % 1000000007;
      first = second;
      second = res;
    }
    return res;
  }
}
```



#### 剑指 Offer 42. 连续子数组的最大和
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```java
class Solution{
  public int maxSubArray(int[] nums){
    int length = nums.length;
    int[] dp = new int[length];
    dp[0] = nums[0];
    int ans = nums[0];
    for (int i = 1; i < length; i++){
      dp[i] = Math.max(0, dp[i - 1]) + nums[i];
      ans = Math.max(dp[i], ans);
    }
    return ans;
  }
}
```



#### 剑指 Offer 47. 礼物的最大价值
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

示例 1:

```
输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
```

```java
class Solution{
  public int maxValue(int[][] grid){
    int row = grid.length;
    int col = grid[0].length;
    int[][] dp = new int[row][col];
    dp[0][0] = grid[0][0];
    for (int i = 1; i < row; i++){
      dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int i = 1; i < col; i++){
      dp[0][i] = dp[0][i - 1] + grid[0][i];
    }
    for (int i = 1; i < row; i++){
      for (int j = 1; j < col; j++){
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
      }
    }
    return dp[row - 1][col - 1];
  }
}
```



#### 剑指 Offer 48. 最长不含重复字符的子字符串
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

示例 1:

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例 2:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例 3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串.
```

```java
class Solution{
  public int lengthOfLongestSubstring(String s) {
    int length = s.length;
    if (length == 0){
      return 0;
    }
    char[] sCs = s.toCharArray();
    Map<Character, Integer> map = new HashMap<>();
    int left = 0, right = 0, ans = 0;
    while (right < length){
      char c = sCs[right];
      right++;
      map.put(c, map.getOrDefault(c, 0) + 1);
      while (map.get(c) > 1){
        char temp = sCs[left];
        left++;
        map.put(temp map.getOrDefault(temp, 0) - 1);
      }
      ans = Math.max(ans, right - left);
    }
    return ans;
  }
}
```



#### 剑指 Offer 49. 丑数
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 

示例:

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

```java
class Solution{
  public int nthUglyNumber(int n){
    int[] res = new int[n];
    int i2 = 0, i3 = 0, i5 = 0;
    res[0] = 1;
    for (int i = 1; i < n; i++){
      res[i] = Math.min(2 * res[i2], Math.min(3 * res[i3], 5 * res[i5]));
      if (res[i] == 2 * res[i2]){
        i2++;
      }
      if (res[i] == 3 * res[i3]){
        i3++;
      }
      if (res[i] == 5 * res[i5]){
        i5++;
      }
    }
    return res[n - 1];
  }
}
```



#### 剑指 Offer 63. 股票的最大利润
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 

示例 1:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

示例 2:

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

```java
class Solution{
  public int maxProfit(int[] prices) {
    int length = prices.length;
    if (length == 0){
      return 0;
    }
    int[] dp = new int[length];
    int minPrice = prices[0];
    for (int i = 1; i < length; i++){
      minPrice = Math.min(minPrice, prices[i]);
      dp[i] = Math.max(dp[i - 1], prices[i] - minPrice);
    }
    return dp[length - 1];
  }
}
```





### 搜索与回溯算法

#### 剑指 Offer 12. 矩阵中的路径
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

示例 2：

```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

```java
class Solution{
  int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
  
  public boolean exist(char[][] board, String word){
    int col = board.length;
    int row = board[0].length;
    boolean[][] visited = new boolean[col][row];
    for (int i = 0; i < col; i++){
      for (int j = 0; j < row; j++){
        if (check(board, i, j, 0 , word, visited)){
          return true;
        }
      }
    }
    return false;
  }
  
  private boolean check(char[][] board, int x, int y, int idx, String word, boolean[][] visited){
    if (board[x][y] != word.charAt(idx)){
      return false;
    }
    if (idx == word.length() - 1){
      return true;
    }
    visited[x][y] = true;
    boolean result = false;
    for (int i = 0; i < 4; i++){
      int newX = x + dirs[i][0];
      int newY = y + dirs[i][1];
      if (newX >= 0 && newY >= 0 && newX < board.length && newY < board[0].length && !visited[newX][newY]){
        if (check(board, newX, newY, idx + 1, word, visited)){
          result = true;
          break;
        }
      }
    }
    visited[x][y] = false;
    return result;
  }
}
```





#### 剑指 Offer 13. 机器人的运动范围
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 

示例 1：

```
输入：m = 2, n = 3, k = 1
输出：3
```

示例 2：

```
输入：m = 3, n = 1, k = 0
输出：1
```

```java
class Solution{
  public int movingCount(int m, int n, int k) {
    boolean[][] visited = new boolean[m][n];
    return ;
  }
  
  private int dfs(int x, int y, int m, int n, int k, boolean[][] visited){
    if (x >= m || y >= n || visited[x][y] || !isValid(x, y, k)){
      return 0;
    }
    visited[x][y] = true;
    return 1 + dfs(x + 1, y, m, n, k, visited) + dfs(x, y + 1, m, n, k, visited);
  }
  
  private boolean isValid(int x, int y, int k){
    int sum = 0;
    while (x > 0){
      sum += x % 10;
      x /= 10;
    }
    while (y > 0){
      sum += y % 10;
      y /= 10;
    }
    return sum <= k;
  }
}
```



#### 剑指 Offer 26. 树的子结构
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

```
     3
    / \
   4   5
  / \
 1   2
```

给定的树 B：

```
  4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

示例 2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

```java
class Solution{
  public boolean isSubStructure(TreeNode A, TreeNode B){
    if (A == null && B == null){
      return true;
    }else if (A == null || B == null){
      return false;
    }
    boolean ans = false;
    if (A.val == B.val){
      ans = doHaveSub(A, B);
    }
    if (!ans){
      ans = isSubStructure(A.left, B);
    }
    if (!ans){
      ans = isSubStructure(A.right, B);
    }
    return ans;
  }
  
  public boolean doHaveSub(TreeNode A, TreeNode B){
    if (A == null && B == null){
      return true;
    }else if (A == null){
      return false;
    }
    return A.val == B.val && doHaveSub(A.left, B.left) && doHaveSub(A.right, B.right);
  }
}
```



#### 剑指 Offer 27. 二叉树的镜像
请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

镜像输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1 
```

示例 1：

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

```java
class Solution{
  public TreeNode mirrorTree(TreeNode root) {
    if (root == null){
      return null;
    }
    TreeNode temp = root.left;
    root.left = mirrorTree(root.right);
    root.right = mirrorTree(temp);
    return root;
  }
}
```



#### 剑指 Offer 28. 对称的二叉树
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

示例 1：

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

示例 2：

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

```java
class Solution{
  public boolean isSymmetric(TreeNode root) {
    return isSymmetric(root, root);
  }
  
  private boolean isSymmetric(TreeNode a, TreeNode b){
    if (a == null && b == null){
      return true;
    }else if (a == null || b == null){
      return false;
    }
    return a.val == b.val && isSymmetric(a.left, b.right) && isSymmetric(a.right, b.left);
  }
}
```



#### 剑指 Offer 32 - I. 从上到下打印二叉树
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```

返回：

```
[3,9,20,15,7]
```

```java
class Solution {
  public int[] levelOrder(TreeNode root) {
    if (root == null){
      return new int[0];
    }
    List<Integer> list = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()){
      int size = queue.size();
      for (int i = 0; i < size; i++){
        TreeNode temp = queue.poll();
        list.add(temp.val);
        if (temp.left != null){
          queue.offer(temp.left);
        }
        if (temp.right != null){
          queue.offer(temp.right);
        }
      }
    }
    int[] ans = new int[list.size()];
    for (int i = 0; i < list.size(); i++){
      ans[i] = list.get(i);
    }
    return ans;
  }
}
```



#### 剑指 Offer 34. 二叉树中和为某一值的路径
输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 

示例:
给定如下二叉树，以及目标和 target = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```

```java
class Solution{
  List<List<Integer>> ans = new ArrayList<>();
  LinkedList<Integer> tempAns = new LinkedList<>();
  
  public List<List<Integer>> pathSum(TreeNode root, int target) {
        preOrder(root, target);
        return ans;
  }
  
  private void preOrder(TreeNode root, int target){
    if (root == null){
      return;
    }
    tempAns.add(root.val);
    target -= root.val;
    if (root.left == null && root.right == null && root.val == target){
      ans.add(new ArrayList(tempAns));
    }
    preOrder(root.left, target);
    preOrder(root.right, target);
    tempAns.removeLast();
  }  
}
```





#### 剑指 Offer 37. 序列化二叉树
请实现两个函数，分别用来序列化和反序列化二叉树。

示例: 

你可以将以下二叉树：

```
    1
   / \
  2   3
     / \
    4   5
```

序列化为 "[1,2,3,null,null,4,5]"

```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        String SEP = ",";
        String NULL = "#";
        serialize(root, SEP, NULL, sb);
        return sb.toString();
    }

    void serialize(TreeNode root, String SEP, String NULL, StringBuilder sb){
      if (root == null){
        sb.append(NULL).append(SEP);
        return;
      }
      sb.append(NULL).append(SEP);
      serialize(root.left, SEP, NULL, sb);
      serialize(root.right, SEP, NULL, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
      String PRE_NULL = "#";
      String PRE_SLICE = ",";
      LinkedList<String> list = new LinkedList<>();
      for (String s : data.split(",")){
        list.add(s);
      }
      return deserialize(list, PRE_NULL);
    }

    TreeNode deserialize(LinkedList<String> list, String PRE_NULL){
      if (list.isEmpty()){
        return null;
      }
      String first = list.removeFirst();
      if (first.equals(PRE_NULL)){
        return null;
      }
      TreeNode root = new TreeNode(Integer.valueOf(first));
      root.left = deserialize(list, PRE_NULL);
      root.right = deserialize(list, PRE_NULL);
      return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```



#### 剑指 Offer 38. 字符串的排列
输入一个字符串，打印出该字符串中字符的所有排列。 

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 

示例:

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

```java
class Solution{
  List<String> ans = new ArrayList<>();
  char[] sCs;
  
  public String[] permutation(String s){
    sCs = s.toCharArray();
    dfs(0);
    return ans.toArray(new String[ans.size]);
  }
  
  void dfs(int n){
    if (n == sCs.length){
      ans.add(String.valueOf(sCs));
      return;
    }
    HashSet<Character> set = new HashSet<>();
    for (int i = n; i < sCs.length; i++){
      if (set.contains(sCs[i])){
        continue;
      }
      set.add(sCs[i]);
      swap(i, n);
      dfs(n + 1);
      swap(i, n);
    }
  }
  
  void swap(int x, int y){
    char temp = sCs[x];
    sCs[x] = sCs[y];
    sCs[y] = temp;
  }
}
```





#### 剑指 Offer 54. 二叉搜索树的第 k 大节点
给定一棵二叉搜索树，请找出其中第k大的节点。 

示例 1:

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

示例 2:

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```

```java
class Solution{
  private int ans;
  private int k;
  
  public int kthLargest(TreeNode root, int k) {
    this.k = k;
    midOrder(root);
    return ans;
  }
  
  void midOrder(TreeNode root){
    if (root == null){
      return ;
    }
    midOrder(root.left);
    if (--k == 0){
      ans = root.val;
      return ;
    }
    midOrder(root.right);
  }
}
```



#### 剑指 Offer 55 - I. 二叉树的深度
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

例如：

给定二叉树 [3,9,20,null,null,15,7]，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```java
class Solution{
  public int maxDepth(TreeNode root){
    if (root == null){
      return 0;
    }
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    return 1 + Math.max(left, right);
  }
}
```



#### 剑指 Offer 55 - II. 平衡二叉树
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

```


       1
      / \
     2   2
    / \

   3   3
  / \
 4   4
```

返回 false 。

```java
class Solution{
  public boolean isBalanced(TreeNode root){
    return recur(root) != -1;
  }
  
  private int recur(TreeNode root){
    if (root == null){
      return 0;
    }
    int left = recur(root.left);
    if (left == -1){
      return -1;
    }
    int right = recur(root.right);
    if (right == -1){
      return -1;
    }
    return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
  }
}
```



#### 剑指 Offer 64. 求 1 + 2 + … + n
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

示例 1：

```
输入: n = 3
输出: 6
```

示例 2：

```
输入: n = 9
输出: 45
```

```java
class Solution{
  public sumNums(int n){
    int result = 0;
    boolean x = n >= 1 && (result = n + sumNums(n - 1)) > 0;
    return result;
  }
}
```



#### 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

示例 2:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      if (p.val > root.val && q.val > root.val){
        return lowestCommonAncestor(root.right, p, q);
      }else if (p.val < root.val && q.val < root.val){
        return lowestCommonAncestor(root.left, p, q);
      }else return root;
}
```



#### 剑指 Offer 68 - II. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

示例 1:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

示例 2:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      if (root == null){
        return null;
      }
      if (p == root || q == root){
        return root;
      }
      TreeNode left = lowestCommonAncestor(root.left, p , q);
      TreeNode right = lowestCommonAncestor(root.right, p , q);
      if (left == null){
        return right;
      }else if (right == null){
        return left;
      }else {
        return root;
      }   
    }
}
```



### 分治算法

#### 剑指 Offer 07. 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

```java
class Solution{
  public TreeNode buildTree(int[] preOrder, int[] midOrder){
    return construct(preOrder, 0, preOrder.length, midOrder, 0, midOrder.length);
  }
  
  private construct(int[] preOrder, int preStart, int preEnd, int[] midOrder, int midStart, int midEnd){
    if (preStart > preEnd){
      return null;
    }
    int rootVal = preOrder[preStart];
    int idx = -1;
    for (int i = midStart; i <= midEnd; i++){
      if (midOrder[i] == rootVal){
        idx = i;
        break;
      }
    }
    int leftSize = idx - midStart;
    TreeNode root = new TreeNode(rootVal);
    root.left = construct(preOrder, preStart + 1, preStart + leftSize, midOrder, midStart, idx - 1);
    root.right = construct(preOrder, preStart + leftSize + 1, preEnd, midOrder, idx + 1, midEnd);
    return root;
  }
}
```



#### 剑指 Offer 16. 数值的整数次方
实现 pow(x, n) ，即计算 x 的 n 次幂函数。不得使用库函数，同时不需要考虑大数问题。 

示例 1：

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

示例 2：

```
输入：x = 2.10000, n = 3
输出：9.26100
```

示例 3：

```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

```java
class Solution {
    public double myPow(double x, int n) {
      if (n == 0){
        return 1;
      }
      double result = 1.0;
      for (int i = n; i != 0; i = i / 2){
        if ((i & 0x1) == 1){
          result *= x;
        }
        x *= x;
      }
      return n < 0 ? 1 / result : result;
    }
}
```



#### 剑指 Offer 33. 二叉搜索树的后序遍历序列
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

示例 1：

```
输入: [1,6,3,2,5]
输出: false
```

示例 2：

```
输入: [1,3,2,6,5]
输出: true
```

```java
class Solution{
  public boolean verifyPostorder(int[] postorder){
    return postOrder(postorder, 0, postorder.length - 1);
  }
  
  private boolean postOrder(int[] postorder, int low, int high){
    if (low >= high){
      return true;
    }
    int p = low;
    while (postorder[p] < postorder[high]){
      p++;
    }
    int m = p;
    while (postorder[p] > postorder[high]){
      p++;
    }
    return p == high && postOrder(postorder, low,  m - 1) postOrder(postorder, m,  high - 1); 
  }
}
```



#### 剑指 Offer 51. 数组中的逆序对
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

示例 1:

```
输入: [7,5,6,4]
输出: 5
```

```java
class Solution{
  int count = 0;
  public int reversePairs(int[] nums){
    int[] temp = new int[nums.length];
    mergerSort(nums, 0, nums.length - 1, temp);
    return count;
  }
  
  private void mergerSort(int[] nums, int low, int high, int[] temp){
    if (low < high){
      int mid = low + ( high - low ) / 2;
      mergerSort(nums, low, mid, temp);
      mergerSort(nums, mid + 1, high, temp);
      merge(nums, low, mid, high, temp);
    }
  }
  
  private void merge(int[] nums, int low, int mid, int high, int[] temp){
    int i = low;
    int j = mid + 1;
    int t = 0;
    while (i <= mid && j <= high){
      if (nums[i] <= nums[j]){
        temp[t++] = nums[i++];
      }else{
        count += (mid - i + 1);
        temp[t++] = nums[j++];
      }
    }
    while (i <= mid){
      temp[t++] = nums[i++];
    }
    while (j <= high){
      temp[t++] = nums[j++];
    }
    t = 0;
    while (low <= high){
      nums[low++] = temp[t++];
    }
  }
}
```



#### 剑指 Offer 40. 最小的 k 个数
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

示例 1：

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

示例 2：

```
输入：arr = [0,1,2,1], k = 1
输出：[0]
```

```java
class Solution{
  private int[] getLeastNumbers(int[] arr, int k){
    if (k == arr.length){
      return arr;
    }
    int low = 0, high = arr.length - 1;
    for (;;){
      int partition = partition(arr, low, high);
      if (partition > k){
        high = partition - 1;
      }else if (patitiion < k){
        low = partition + 1;
      }else{
        return Arrays.copyOf(arr, partition);
      }
    }
  }
  
  private int partition(int[] nums, int low, int high){
    int pivot = nums[low];
    while (low < high){
      while (low < high && nums[high] >= pivot){
        --high;
      }
      nums[low] = nums[high];
      while (low < high && nums[low] <= pivot){
        ++low;
      }
      nums[high] = nums[low];
    }
    nums[low] = pivot;
    return low;
  }
}
```



#### 剑指 Offer 41. 数据流中的中位数
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

- void addNum(int num) - 从数据流中添加一个整数到数据结构中。

- double findMedian() - 返回目前所有元素的中位数。

示例 1：

输入：

```
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
```

示例 2：

输入：

```
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]
```

```java
class MedianFinder{
  private PriorityQueue<Integer> large;
  private PriorityQueue<Integer> smalll;
  
  public MedianFinder(){
    large = new PriorityQueue<>();
    smalll = new PriorityQueue<>((a, b) -> b - a);
  }
  
  public void addNum(int num){
    if (small.size() > large.size()){
      small.offer(num);
      large.offer(small.poll());
    }else{
      large.offer(num);
      small.offer(large.poll());
    }
  }
  
  public double findMedian(){
    if (large.size() > small.size()){
      return large.peek();
    }else if (small.size() > large.size()){
      return small.peek();
    }else{
      return (large.peek() + small.peek()) / 2.0;
    }
  }
}
```



#### 剑指 Offer 45. 把数组排成最小的数
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 

示例 1:

```
输入: [10,2]
输出: "102"
```

示例 2:

```
输入: [3,30,34,5,9]
输出: "3033459"
```

```java
class Solution{
  public String minNumber(int[] nums){
    int length = nums.length;
    String[] s = new String[length];
    for (int i = 0; i < length; i++){
      s[i] = String.valueOf(nums[i]);
    }
    Arrays.sort(s, (x, y) -> (x + y).compareTo(y + x));
    StringBuilder sb = new StringBuilder();
    for (String temp : s){
      sb,append(temp);
    }
    return sb.toString();
  }
}
```



#### 剑指 Offer 61. 扑克牌中的顺子
从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

 示例 1:

```
输入: [1,2,3,4,5]
输出: True
```


示例 2:

```
输入: [0,0,1,2,5]
输出: True
```

```java
class Solution{
  public boolean isStraight(int[] nums){
    quickSort(nums, 0, nums.length - 1);
    int left = 0;
    for (int i = 0; i < 4; i++){
      if (nums[i] == 0){
        left++;
      }else if (nums[i] == nums[i + 1]){
        return false;
      }
    }
    return nums[4] - nums[left] < 5;
  }
  
  
  private partition(int[] nums, int low, int high){
    int pivot = nums[low];
    while (low < high){
      while (low < high && nums[high] >= pivot){
        --high;
      }
      while (low < high && nums[low] <= pivot){
        ++low;
      }
    }
    nums[low] = pivot;
    return low;
  }
  
  private void quickSort(int[] nums, int low, int high){
    if (low < high){
      int partition = partition(nums, low, high);
      quickSort(nums, low, partition - 1);
      quickSort(nums, partition + 1, high);
    }
  }
}
```



### 查找算法

#### 剑指 Offer 03. 数组中重复的数字
找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

```java
class Solution{
  public int findRepeatNumber(int[] nums){
    for (int i = 0; i < nums.length; i++){
      int temp = nums[i];
      if (nums[i] != i){
        if (temp = nums[temp]){
          return temp;
        }
        nums[i] = nums[temp];
        nums[temp] = temp;
      }
    }
    return -1;
  }
}
```



#### 剑指 Offer 04. 二维数组中的查找
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 

示例:

```
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

```java
class Solution{
  public boolean findNumberIn2DArray(int[][] matrix, int target){
    if (matrix == null || matrix.length == 0){
      return false;
    }
    int col = matrix.length;
    int row = matrix[0].length;
    int nc = col - 1;
    int nr = 0;
    while (nc >= 0 && nr < row){
      if (matrix[nc][nr] > target){
        nc--;
      }else if (matrix[nc][nr] < target){
        nr++;
      }else {
        return true;
      }
    }
    return false;
  }
}
```



#### 剑指 Offer 11. 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

```
输入：[3,4,5,1,2]
输出：1
```

示例 2：

```
输入：[2,2,2,0,1]
输出：0
```

```java
class Solution{
  public int minArray(int[] numbers){
    int low = 0, high = numbers.length - 1;
    if (numbers[low] < nums[high]){
      return numbers[low];
    }
    while (low <= high){
      int mid = low + (high - low) / 2;
      if (numbers[mid] > numbers[high]){
        low = mid + 1;
      }else if (numbers[mid] < numbers[high]){
        high = mid;
      }else{
        high--
      }
    }
    return numbers[low];
  }
}
```



#### 剑指 Offer 50. 第一个只出现一次的字符
在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

示例:

```
s = "abaccdeff"
返回 "b"

s = "" 
返回 " "
```

```java
class Solution{
  public char firstUniqChar(String s){
    LinkedHashMap<Character, Boolean> help = new LinkedHashMap<>();
    char[] sCs = s.toCharArray();
    for (Character c : sCs){
      help.put(c, help.containsKey(c));
    }
    for (Map.Entry<Character, Boolean> entry : help.entrySet()){
      if (!entry.getValue()){
        return entry.getKey();
      }
    }
    return '';
  }
}
```



#### 剑指 Offer 53 - I. 在排序数组中查找数字 I
统计一个数字在排序数组中出现的次数。 

示例 1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

示例 2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

```java
class Solution{
  public int search(int[] nums, int target){
    return leftBounds(nums, target + 1) - leftBounds(nums, target);
  }
  
  private int leftBounds(int[] nums, int target){
    int low = 0, high = nums.length - 1;
    while (low <= high){
      int mid = low + (high - low) / 2;
      if (nums[mid] < target){
        low = mid + 1;
      }else{
        high = mid - 1;
      }
    }
    return low;
  }
  
  private int rigthBounds(int[] nums, int target){
    int low = 0, high = nums.length - 1;
    while (low <= high){
      int mid = low + (high - low) / 2;
      if (nums[mid] <= target){
        low = mid + 1;
      }else{
        high = mid - 1;
      }
    }
    return high;
  }
}
```



#### 剑指 Offer 53 - II. 0～n-1 中缺失的数字
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:

```
输入: [0,1,3]
输出: 2
```

示例 2:

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

```java
class Solution{
  public int missingNumber(int[] nums){
    int low = 0, high = nums.length - 1;
    while (low <= high){
      int mid = low + (high - low) / 2;
      if (nums[mid] == mid){
        low = mid + 1;
      }else{
        high = mid - 1;
        // 实际只存在 nums[mid] == mid 和 nums[mid] > mid 两种情况
      }
    }
    return low;
  }
}
```



### 双指针

#### 剑指 Offer 18. 删除链表的节点
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

示例 2:

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

```java
class Solution{
  public ListNode deleteNode(ListNode head, int val){
    ListNode fast = head;
    if (fast.val == val){
      return fast.next;
    }
    while (fast != null){
      if (fast.next.val == val){
        break;
      }
      fast = fast.next;
    }
    fast.next = fast.next.next;
    return head;
  }
}
```



#### 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

```java
class Solution{
  public int[] exchange(int[] nums){
    int low = 0, high = nums.length - 1;
    while (low < high){
      while (low < high && (nums[low] & 0x1) == 1){
        low++;
      }
      while (low < high && (nums[high] & 0x1) == 0){
        high--;
      }
      int temp = nusm[low];
      nums[low] = nums[high];
      nums[high] = temp;
    }
    return nums;
  }
}
```



#### 剑指 Offer 22. 链表中倒数第 k 个节点
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

示例：

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

```java
class Solution{
  public ListNode getKthFromEnd(ListNode head, int k){
    ListNode slow = head, fast = head;
    for (int i = 0; i < k; i++){
      fast = fast.next;
    }
    while (fast != null){
      slow = slow.next;
      fast = fast.next;
    }
    return slow;
  }
}
```



#### 剑指 Offer 25. 合并两个排序的链表
输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

示例1：

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

```java
class Solution{
  //递归
  public ListNode mergeTwoList(ListNode l1, ListNode l2){
    if (l1 == null){
      return l2;
    }else if (l2 == null){
      return l1;
    }else if (l1.val <= l2.val){
      l1.next = mergeTwoList(l1.next, l2);
      return l1;
    }else {
      l2.next = mergeTwoList(l1, l2.next);
      return l2;
    }
  }
  
  //迭代
  public ListNode mergeTwoList(ListNode l1, ListNode l2){
    ListNode dummy = new ListNode(0);
    ListNode newHead = dummy;
    while (l1 != null && l2 != null){
      if (l1.val <= l2.val){
        dummy.next = l1;
        l1 = l1.next;
      }else{
        dummy.next = l2;
        l2 = l2.next;
      }
      dummy = dummy.next;
    }
    dummy.next = l1 == null ? l2 : l1;
    return newHead.next;
  }
}
```



#### 剑指 Offer 52. 两个链表的第一个公共节点
输入两个链表，找出它们的第一个公共节点。

```java
class Solution{
  public ListNode getIntersectionNode(ListNode headA, ListNode headB){
    ListNode fast = headA, slow = headB;
    while (fast != slow){
      fast = fast == null ? headB : fast.next;
      slow = slow == null ? headA : slow.next;
    }
    return fast;
  }
}
```



#### 剑指 Offer 57. 和为 s 的两个数字
输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

示例 2：

```
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```

```java
class Solution{
  public int[] twoSum(int[] nums, int target){
    int low = 0, high = nums.length - 1;
    while (low <= high){
      if (nums[low] + nums[high] < target){
        low++;
      }else if (nums[low] + nums[high] > target){
        high--;
      }else{
        return new int[]{nums[low], nums[high]};
      }
    }
    return new int[0];
  }
}
```



#### 剑指 Offer 58 - I. 翻转单词顺序
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。 

示例 1：

```
输入: "the sky is blue"
输出: "blue is sky the"
```

示例 2：

```
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
```

示例 3：

```
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```

```java
class Solution{
  public String reverseWords(String s){
    char[] sCs = s.toCharArray();
    int low = sCs.length - 1, high = low;
    StringBuilder sb = new StringBuilder();
    while (low >= 0){
      while (low >= 0 && sCs[low] != ' '){
        low--;
      }
      sb.append(s.substring(low + 1, high + 1) + ' ');
      while (low >= 0 && sCs[low] == ' '){
        low--;
      }
      high = low;
    }
    return sb.toString().trim();
  }
}
```



### 数学

#### 剑指 Offer 39. 数组中出现次数超过一半的数字
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

```java
class Solution{
  public int majorityElement(int[] nums){
    int vote = 0, x = 0;
    for (int num : nums){
      if (vote = 0){
        x = num;
      }
      vote += num == x ? 1 : -1;
    }
    return x;
  }
}
```



#### 剑指 Offer 44. 数字序列中某一位的数字
数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

示例 1：

```
输入：n = 3
输出：3
```

示例 2：

```
输入：n = 11
输出：0
```

```java
class Solution{
  public int findNthDigit(int n){
    int size = 1;
    int max = 9;
    int temp = n;
    while (temp - max * size > 0){
      temp -= max * size;
      size++;
      max *= 10;
    }
    if (size == 1){
      return n;
    }
    int num = (int)(Math.pow(10, size - 1) + temp / size);
    int idx = temp % size;
    if (idx == 0){
      return numToArray(num - 1, size)[size - 1];
    }
    return numToArray(num, size)[idx - 1];
  }
  
  private int[] numToArray(int num, int size){
    int[] res = new int[size];
    size--;
    while (num > 0){
      res[size--] = num % 10;
      num /= 10;
    }
    return res;
  }
}
```



#### 剑指 Offer 57 - II. 和为 s 的连续正数序列
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

示例 1：

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```

示例 2：

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

```java
class Solution{
  public int[][] findContinuousSequence(int target){
    int low = 1, high = 2, sum = 3;
    List<int[]> tempAns = new ArrayList<>();
    while (low < high){
      if (sum == target){
        int size = high - low + 1;
        int[] temp = new int[size];
        for (int i = 0; i < size; i++){
          temp[i] = low + i;
        }
        tempAns.add(temp);
      }
      if (sum < target){
        high++;
        sum += high;
      }else if (sum >= target){
        sum -= low;
        low++;
      }
    }
    return tempAns.toArray(new int[0][]);
  }
}
```



#### 剑指 Offer 66. 构建乘积数组
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

示例:

```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

```java
class Solution{
  public int[] constructArr(int[] a){
    int size = a.length;
    if (size == 0){
      return new int[0];
    }
    int[] L = new int[size];
    int[] R = new int[size];
    L[0] = 1;
    for (int i = 1; i < size; i++){
      L[i] = L[i - 1] * a[i - 1];
    }
    R[size - 1] = 1;
    for (int i = size - 2; i >= 0; i--){
      R[i] = R[i + 1] * a[i + 1];
    }
    int[] res = new int[size];
    for (int i = 0; i < size; i++){
      res[i] = L[i] * R[i];
    }
    return res;
  }
}
```



### 模拟

#### 剑指 Offer 29. 顺时针打印矩阵
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

示例 1：

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

示例 2：

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

```java
class Solution{
  public int[] spiralOrder(int[][] matrix){
    if (matrix == null || matrix.length == 0){
      return new int[0];
    }
    int left = 0, right = matrix[0].length - 1, top = 0, down = matrix.length;
    int[] ans = new int[(right + 1) * (down + 1)];
    int idx = 0;
    for (;;){
      for (int i = left; i <= right; i++){
        ans[idx++] = matrix[top][i];
      }
      if (++top > down){
        break;
      }
      for (int i = top; i <= down; i++){
        ans[idx++] = matrix[i][right];
      }
      if (--right < left){
        break;
      }
      for (int i = right; i >= left; i--){
        ans[idx++] == matrix[down][i]
      }
      if (--down < top){
        break;
      }
      for (int i = down; i >= top; i--){
        ans[idx++] = matrix[i][left];
      }
      if (++left > right){
        break;
      }
    }
    return ans;
  }
}
```



#### 剑指 Offer 31. 栈的压入、弹出序列
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

示例 2：

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

```java
class Solution{
  public boolean validateStackSequences(int[] pushed, int[] popped){
    if (pushed.length == 0 || popped.length == 0){
      return true;
    }
    Stack<Integer> help = new Stack<>();
    int j = 0;
    for (int i : pushed){
      help.push(i);
      while (!help.isEmpty() && help.peek() == popped[j]){
        help.pop();
        j++
      }
    }
    return help.isEmpty();
  }
}
```


