# 算法题

### 数据结构

#### 剑指 Offer 05. 替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

```java
class Solution{
  public String replaceSpace(String s){
    char[] sCs = s.toCharArray();
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < sCs.legnth; i++){
      if (sCs[i] == ' '){
        sb.append("%20");
      }else{
        sb.append(sCs[i]);
      }
    }
    return sb.toString();
  }
}
```



#### 剑指 Offer 06. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

```
输入：head = [1,3,2]
输出：[2,3,1]
```

```java
class Solution{
  public int[] reversePrint(ListNode head){
    if (head == null){
      return new int[0];
    }
    Stack<Integer> stack = new Stack<>();
    while (head != null){
      stack.push(head.val);
      head = head.next;
    }
    int length = stack.size;
    int[] res = new int[length];
    for (int i = 0; i < length; i++){
      res[i] = stack.pop();
    }
    return res;
  }
}
```



#### 剑指 Offer 09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

示例 1：

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

示例 2：

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

```java
class CQueue{
  Stack<Integer> stack1;
  Stack<Integer> stack2;
  
  public CQueue(){
    stack1 = new Stack<>();
    stack2 = new Stack<>();
  }
  
  public void appendTail(int value){
    stack1.push(value);
  }
  
  public int deleteHead(){
    if (!stack2.isEmpty()){
      return stack2.pop();
    }else if (stack1.isEmpty()){
      return -1;
    }
    while (!stack1.isEmpty()){
      stack2.push(stack1.pop());
    }
    return stack2.pop();
  }
}
```



##### 剑指 Offer 20. 表示数值的字符串
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。

数值（按顺序）可以分成以下几个部分：

1. 若干空格
2. 一个 小数 或者 整数
3. （可选）一个 'e' 或 'E' ，后面跟着一个 整数
4. 若干空格小数（按顺序）可以分成以下几个部分：


示例 1：

```
输入：s = "0"
输出：true
```

示例 2：

```
输入：s = "e"
输出：false
```

示例 3：

```
输入：s = "."
输出：false
```

示例 4：

```
输入：s = "    .1  "
输出：true
```

```java
class Solution{
	public boolean isNumber(String s){
    char[] sCs = s.trim().toCharArray();
    int length = sCs.length;
    boolean isNum = false, isDot = false, iseOrE = false;
    for (int i = 0; i < length; i++){
      char c = sCs[i];
      if (c >= '0' && c <= '9'){
        isNum = true;
      }else if (c == '.'){
        if (iseOrE || isDot){
          return false;
        }
        idDot = true;
      }else if (c == 'e' || c == 'E'){
        if (iseOrE || !isNum){
          return false;
        }
        isNum = false;
        iseOrE = true;
      }else if (c == '+' || c == '-'){
        if (i != 0 && sCs[i - 1] != 'E' && sCs[i - 1] != 'e'){
          return false;
        }
      }else {return false;}
    }
    return isNum;
  }
}
```



#### 剑指 Offer 24. 反转链表
定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

```java
class Solution{
	public ListNode reverseList(ListNode head){
    if (head == null || head.next == null){
      return head;
    }
    ListNode temp = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return temp;
  }
}
```



#### 剑指 Offer 30. 包含 min 函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

示例:

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

```java
class MinStack{
  Stack<Integer> stack1;
  Stack<Integer> stack2;
  
  public MinStack(){
    stack1 = new Stack<>();
    stack2 = new Stack<>();
  }
  
  public void push(int x){
    stack1.push(x);
    if (stack2.isEmpty() || stack2.peek() >= x){
      stack2.push(x);
    }
  }
  
  public void pop(){
    if (stack2.peek().equals(stack1.peek())){
      stack2.pop();
    }
    stack1.pop();
  }
  
  public int top(){
    return stack1.peek();
  }
  
  public int min(){
    return stack2.peek();
  }
}
```



#### 剑指 Offer 35. 复杂链表的复制
请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

```java
class Solution{
  public Node copyRandomList(Node head){
    Node cur = head;
    Map<Node, Node> map = new HashMap<>();
    if (head == null){
      return null;
    }
    while (cur != null){
      map.put(cur, new Node(cur,val));
      cur = cur.next;
    }
    cur = head;
    while (cur != null){
      map.get(cur).next = map.get(cur.next);
      map.get(cur).random = map.get(cur.random);
      cur = cur.next;
    }
    return map.get(head);
  }
}
```



#### 剑指 Offer 58 - II. 左旋转字符串
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。 

示例 1：

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

示例 2：

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

```java
class Solution{
  public String reverseLeftWords(String s, int n){
    char[] sCs = s.toCharArray();
    StringBuilder sb = new StringBuilder();
    for (int i = n; i < sCs.length; i++){
      sb.append(sCs[i]);
    }
    for (int i = 0; i < n; i++){
      sb.append(sCs[i]);
    }
    return sb.toString();
  }
}
```



#### 剑指 Offer 59 - I. 滑动窗口的最大值

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

示例:

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值

---------------               -----

[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```



#### 剑指 Offer 59 - II. 队列的最大值
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

示例 2：

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

```java
class MaxQueue{
  Queue<Integer> queue;
  Deque<Integer> deque;
  
  public MaxQueue(){
    queue = new LinkedList<>();
    deque = new LinkedList<>();
  }
  
  public int max_value(){
    return deque.isEmpty() ? -1 : deque.peekFirst();
  }
  
  public void push_back(int value){
    queue.offer(value);
    while (!deque.isEmpty() && deque.peekLast() < value){
      deque.pollLast();
    }
    deque.offer(value);
  }
  
  public int pop_front(){
    if (queue.isEmpty()){
      return -1;
    }
    if (queue.peek().equals(deque.peekFirst())){
      deque.pollFirst();
    }
    return queue.poll();
  }
}
```



#### 剑指 Offer 67. 把字符串转换成整数

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

```java
class Solution{
  public int strToInt(String str){
    int length = str.length;
    if (length == 0){
      return 0;
    }
    char[] strCs = str.toCharArray();
    int ans = 0;
    int sign = 1;
    int i = 0;
    while (strCs[i] == ' '){
      if (++i == length){
        return 0;
      }
    }
    if (strCs[i] == '-'){
      sign = -1;
    }
    if (strCs[i] == '-' || strCs[i] == '+'){
      i++;
    }
    while (i < length){
      if (strCs[i] < '0' || strCs[i] > '9'){
        return sign * ans;
      }else if (ans > Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 && strCs[i] - '0' > Integer.MAX_VALUE % 10)){
        return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
      }
      ans = ans * 10 + (strCs[i] - '0');
      i++
    }
    return sign * ans;
  }
}
```



### 动态规划

#### 剑指 Offer 10- I. 斐波那契数列
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

```
输入：n = 2
输出：1
```

示例 2：

```
输入：n = 5
输出：5
```

```java
class Solution{
  public int fib(int n){
    if (n < 2){
      return n;
    }
    int first = 0, second = 1, res = 0;
    for (int i = 1; i < n; i++){
      res = (first + second) % 1000000007;
      first = second;
      second = res;
    }
    return res;
  }
}
```



#### 剑指 Offer 42. 连续子数组的最大和
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```java
class Solution{
  public int maxSubArray(int[] nums){
    int length = nums.length;
    int[] dp = new int[length];
    dp[0] = nums[0];
    int ans = nums[0];
    for (int i = 1; i < length; i++){
      dp[i] = Math.max(0, dp[i - 1]) + nums[i];
      ans = Math.max(dp[i], ans);
    }
    return ans;
  }
}
```



#### 剑指 Offer 47. 礼物的最大价值
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

示例 1:

```
输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
```

```java
class Solution{
  public int maxValue(int[][] grid){
    int row = grid.length;
    int col = grid[0].length;
    int[][] dp = new int[row][col];
    dp[0][0] = grid[0][0];
    for (int i = 1; i < row; i++){
      dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int i = 1; i < col; i++){
      dp[0][i] = dp[0][i - 1] + grid[0][i];
    }
    for (int i = 1; i < row; i++){
      for (int j = 1; j < col; j++){
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
      }
    }
    return dp[row - 1][col - 1];
  }
}
```



#### 剑指 Offer 48. 最长不含重复字符的子字符串
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

示例 1:

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例 2:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例 3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串.
```

```java
class Solution{
  public int lengthOfLongestSubstring(String s) {
    int length = s.length;
    if (length == 0){
      return 0;
    }
    char[] sCs = s.toCharArray();
    Map<Character, Integer> map = new HashMap<>();
    int left = 0, right = 0, ans = 0;
    while (right < length){
      char c = sCs[right];
      right++;
      map.put(c, map.getOrDefault(c, 0) + 1);
      while (map.get(c) > 1){
        char temp = sCs[left];
        left++;
        map.put(temp map.getOrDefault(temp, 0) - 1);
      }
      ans = Math.max(ans, right - left);
    }
    return ans;
  }
}
```



#### 剑指 Offer 49. 丑数
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 

示例:

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

```java
class Solution{
  public int nthUglyNumber(int n){
    int[] res = new int[n];
    int i2 = 0, i3 = 0, i5 = 0;
    res[0] = 1;
    for (int i = 1; i < n; i++){
      res[i] = Math.min(2 * res[i2], Math.min(3 * res[i3], 5 * res[i5]));
      if (res[i] == 2 * res[i2]){
        i2++;
      }
      if (res[i] == 3 * res[i3]){
        i3++;
      }
      if (res[i] == 5 * res[i5]){
        i5++;
      }
    }
    return res[n - 1];
  }
}
```



#### 剑指 Offer 63. 股票的最大利润
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 

示例 1:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

示例 2:

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

```java
class Solution{
  public int maxProfit(int[] prices) {
    int length = prices.length;
    if (length == 0){
      return 0;
    }
    int[] dp = new int[length];
    int minPrice = prices[0];
    for (int i = 1; i < length; i++){
      minPrice = Math.min(minPrice, prices[i]);
      dp[i] = Math.max(dp[i - 1], prices[i] - minPrice);
    }
    return dp[length - 1];
  }
}
```





### 搜索与回溯算法

#### 剑指 Offer 12. 矩阵中的路径
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

示例 2：

```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

```java
class Solution{
  int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
  
  public boolean exist(char[][] board, String word){
    int col = board.length;
    int row = board[0].length;
    boolean[][] visited = new boolean[col][row];
    for (int i = 0; i < col; i++){
      for (int j = 0; j < row; j++){
        if (check(board, i, j, 0 , word, visited)){
          return true;
        }
      }
    }
    return false;
  }
  
  private boolean check(char[][] board, int x, int y, int idx, String word, boolean[][] visited){
    if (board[x][y] != word.charAt(idx)){
      return false;
    }
    if (idx == word.length() - 1){
      return true;
    }
    visited[x][y] = true;
    boolean result = false;
    for (int i = 0; i < 4; i++){
      int newX = x + dirs[i][0];
      int newY = y + dirs[i][1];
      if (newX >= 0 && newY >= 0 && newX < board.length && newY < board[0].length && !visited[newX][newY]){
        if (check(board, newX, newY, idx + 1, word, visited)){
          result = true;
          break;
        }
      }
    }
    visited[x][y] = false;
    return result;
  }
}
```





#### 剑指 Offer 13. 机器人的运动范围
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 

示例 1：

```
输入：m = 2, n = 3, k = 1
输出：3
```

示例 2：

```
输入：m = 3, n = 1, k = 0
输出：1
```

```java
class Solution{
  public int movingCount(int m, int n, int k) {
    boolean[][] visited = new boolean[m][n];
    return ;
  }
  
  private int dfs(int x, int y, int m, int n, int k, boolean[][] visited){
    if (x >= m || y >= n || visited[x][y] || !isValid(x, y, k)){
      return 0;
    }
    visited[x][y] = true;
    return 1 + dfs(x + 1, y, m, n, k, visited) + dfs(x, y + 1, m, n, k, visited);
  }
  
  private boolean isValid(int x, int y, int k){
    int sum = 0;
    while (x > 0){
      sum += x % 10;
      x /= 10;
    }
    while (y > 0){
      sum += y % 10;
      y /= 10;
    }
    return sum <= k;
  }
}
```



#### 剑指 Offer 26. 树的子结构
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

```
     3
    / \
   4   5
  / \
 1   2
```

给定的树 B：

```
  4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

示例 2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

```java
class Solution{
  public boolean isSubStructure(TreeNode A, TreeNode B){
    if (A == null && B == null){
      return true;
    }else if (A == null || B == null){
      return false;
    }
    boolean ans = false;
    if (A.val == B.val){
      ans = doHaveSub(A, B);
    }
    if (!ans){
      ans = isSubStructure(A.left, B);
    }
    if (!ans){
      ans = isSubStructure(A.right, B);
    }
    return ans;
  }
  
  public boolean doHaveSub(TreeNode A, TreeNode B){
    if (A == null && B == null){
      return true;
    }else if (A == null){
      return false;
    }
    return A.val == B.val && doHaveSub(A.left, B.left) && doHaveSub(A.right, B.right);
  }
}
```



#### 剑指 Offer 27. 二叉树的镜像
请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

镜像输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1 
```

示例 1：

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

```java
class Solution{
  public TreeNode mirrorTree(TreeNode root) {
    if (root == null){
      return null;
    }
    TreeNode temp = root.left;
    root.left = mirrorTree(root.right);
    root.right = mirrorTree(temp);
    return root;
  }
}
```



#### 剑指 Offer 28. 对称的二叉树
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

示例 1：

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

示例 2：

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

```java
class Solution{
  public boolean isSymmetric(TreeNode root) {
    return isSymmetric(root, root);
  }
  
  private boolean isSymmetric(TreeNode a, TreeNode b){
    if (a == null && b == null){
      return true;
    }else if (a == null || b == null){
      return false;
    }
    return a.val == b.val && isSymmetric(a.left, b.right) && isSymmetric(a.right, b.left);
  }
}
```



#### 剑指 Offer 32 - I. 从上到下打印二叉树
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```

返回：

```
[3,9,20,15,7]
```

```java
class Solution {
  public int[] levelOrder(TreeNode root) {
    if (root == null){
      return new int[0];
    }
    List<Integer> list = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()){
      int size = queue.size();
      for (int i = 0; i < size; i++){
        TreeNode temp = queue.poll();
        list.add(temp.val);
        if (temp.left != null){
          queue.offer(temp.left);
        }
        if (temp.right != null){
          queue.offer(temp.right);
        }
      }
    }
    int[] ans = new int[list.size()];
    for (int i = 0; i < list.size(); i++){
      ans[i] = list.get(i);
    }
    return ans;
  }
}
```



#### 剑指 Offer 34. 二叉树中和为某一值的路径
输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 

示例:
给定如下二叉树，以及目标和 target = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```

```java
class Solution{
  List<List<Integer>> ans = new ArrayList<>();
  LinkedList<Integer> tempAns = new LinkedList<>();
  
  public List<List<Integer>> pathSum(TreeNode root, int target) {
        preOrder(root, target);
        return ans;
  }
  
  private void preOrder(TreeNode root, int target){
    if (root == null){
      return;
    }
    tempAns.add(root.val);
    target -= root.val;
    if (root.left == null && root.right == null && root.val == target){
      ans.add(new ArrayList(tempAns));
    }
    preOrder(root.left, target);
    preOrder(root.right, target);
    tempAns.removeLast();
  }  
}
```





#### 剑指 Offer 37. 序列化二叉树
请实现两个函数，分别用来序列化和反序列化二叉树。

示例: 

你可以将以下二叉树：

```
    1
   / \
  2   3
     / \
    4   5
```

序列化为 "[1,2,3,null,null,4,5]"

```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        String SEP = ",";
        String NULL = "#";
        serialize(root, SEP, NULL, sb);
        return sb.toString();
    }

    void serialize(TreeNode root, String SEP, String NULL, StringBuilder sb){
      if (root == null){
        sb.append(NULL).append(SEP);
        return;
      }
      sb.append(NULL).append(SEP);
      serialize(root.left, SEP, NULL, sb);
      serialize(root.right, SEP, NULL, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
      String PRE_NULL = "#";
      String PRE_SLICE = ",";
      LinkedList<String> list = new LinkedList<>();
      for (String s : data.split(",")){
        list.add(s);
      }
      return deserialize(list, PRE_NULL);
    }

    TreeNode deserialize(LinkedList<String> list, String PRE_NULL){
      if (list.isEmpty()){
        return null;
      }
      String first = list.removeFirst();
      if (first.equals(PRE_NULL)){
        return null;
      }
      TreeNode root = new TreeNode(Integer.valueOf(first));
      root.left = deserialize(list, PRE_NULL);
      root.right = deserialize(list, PRE_NULL);
      return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```



#### 剑指 Offer 38. 字符串的排列
输入一个字符串，打印出该字符串中字符的所有排列。 

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 

示例:

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

```java
class Solution{
  List<String> ans = new ArrayList<>();
  char[] sCs;
  
  public String[] permutation(String s){
    sCs = s.toCharArray();
    dfs(0);
    return ans.toArray(new String[ans.size]);
  }
  
  void dfs(int n){
    if (n == sCs.length){
      ans.add(String.valueOf(sCs));
      return;
    }
    HashSet<Character> set = new HashSet<>();
    for (int i = n; i < sCs.length; i++){
      if (set.contains(sCs[i])){
        continue;
      }
      set.add(sCs[i]);
      swap(i, n);
      dfs(n + 1);
      swap(i, n);
    }
  }
  
  void swap(int x, int y){
    char temp = sCs[x];
    sCs[x] = sCs[y];
    sCs[y] = temp;
  }
}
```





#### 剑指 Offer 54. 二叉搜索树的第 k 大节点
给定一棵二叉搜索树，请找出其中第k大的节点。 

示例 1:

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

示例 2:

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```

```java
class Solution{
  private int ans;
  private int k;
  
  public int kthLargest(TreeNode root, int k) {
    this.k = k;
    midOrder(root);
    return ans;
  }
  
  void midOrder(TreeNode root){
    if (root == null){
      return ;
    }
    midOrder(root.left);
    if (--k == 0){
      ans = root.val;
      return ;
    }
    midOrder(root.right);
  }
}
```



#### 剑指 Offer 55 - I. 二叉树的深度
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

例如：

给定二叉树 [3,9,20,null,null,15,7]，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```java
class Solution{
  public int maxDepth(TreeNode root){
    if (root == null){
      return 0;
    }
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    return 1 + Math.max(left, right);
  }
}
```



#### 剑指 Offer 55 - II. 平衡二叉树
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

```


       1
      / \
     2   2
    / \

   3   3
  / \
 4   4
```

返回 false 。

```java
class Solution{
  public boolean isBalanced(TreeNode root){
    return recur(root) != -1;
  }
  
  private int recur(TreeNode root){
    if (root == null){
      return 0;
    }
    int left = recur(root.left);
    if (left == -1){
      return -1;
    }
    int right = recur(root.right);
    if (right == -1){
      return -1;
    }
    return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
  }
}
```



#### 剑指 Offer 64. 求 1 + 2 + … + n
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

示例 1：

```
输入: n = 3
输出: 6
```

示例 2：

```
输入: n = 9
输出: 45
```

```java
class Solution{
  public sumNums(int n){
    int result = 0;
    boolean x = n >= 1 && (result = n + sumNums(n - 1)) > 0;
    return result;
  }
}
```



#### 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

示例 2:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      if (p.val > root.val && q.val > root.val){
        return lowestCommonAncestor(root.right, p, q);
      }else if (p.val < root.val && q.val < root.val){
        return lowestCommonAncestor(root.left, p, q);
      }else return root;
}
```



#### 剑指 Offer 68 - II. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

示例 1:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

示例 2:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      if (root == null){
        return null;
      }
      if (p == root || q == root){
        return root;
      }
      TreeNode left = lowestCommonAncestor(root.left, p , q);
      TreeNode right = lowestCommonAncestor(root.right, p , q);
      if (left == null){
        return right;
      }else if (right == null){
        return left;
      }else {
        return root;
      }   
    }
}
```



### 分治算法

#### 剑指 Offer 07. 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

```java
class Solution{
  public TreeNode buildTree(int[] preOrder, int[] midOrder){
    return construct(preOrder, 0, preOrder.length, midOrder, 0, midOrder.length);
  }
  
  private construct(int[] preOrder, int preStart, int preEnd, int[] midOrder, int midStart, int midEnd){
    if (preStart > preEnd){
      return null;
    }
    int rootVal = preOrder[preStart];
    int idx = -1;
    for (int i = midStart; i <= midEnd; i++){
      if (midOrder[i] == rootVal){
        idx = i;
        break;
      }
    }
    int leftSize = idx - midStart;
    TreeNode root = new TreeNode(rootVal);
    root.left = construct(preOrder, preStart + 1, preStart + leftSize, midOrder, midStart, idx - 1);
    root.right = construct(preOrder, preStart + leftSize + 1, preEnd, midOrder, idx + 1, midEnd);
    return root;
  }
}
```



#### 剑指 Offer 16. 数值的整数次方
实现 pow(x, n) ，即计算 x 的 n 次幂函数。不得使用库函数，同时不需要考虑大数问题。 

示例 1：

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

示例 2：

```
输入：x = 2.10000, n = 3
输出：9.26100
```

示例 3：

```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

```java
class Solution {
    public double myPow(double x, int n) {
      if (n == 0){
        return 1;
      }
      double result = 1.0;
      for (int i = n; i != 0; i = i / 2){
        if ((i & 0x1) == 1){
          result *= x;
        }
        x *= x;
      }
      return n < 0 ? 1 / result : result;
    }
}
```



#### 剑指 Offer 33. 二叉搜索树的后序遍历序列
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

示例 1：

```
输入: [1,6,3,2,5]
输出: false
```

示例 2：

```
输入: [1,3,2,6,5]
输出: true
```

```java
class Solution{
  public boolean verifyPostorder(int[] postorder){
    return postOrder(postorder, 0, postorder.length - 1);
  }
  
  private boolean postOrder(int[] postorder, int low, int high){
    if (low >= high){
      return true;
    }
    int p = low;
    while (postorder[p] < postorder[high]){
      p++;
    }
    int m = p;
    while (postorder[p] > postorder[high]){
      p++;
    }
    return p == high && postOrder(postorder, low,  m - 1) postOrder(postorder, m,  high - 1); 
  }
}
```



#### 剑指 Offer 51. 数组中的逆序对
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

示例 1:

```
输入: [7,5,6,4]
输出: 5
```

```java
class Solution{
  int count = 0;
  public int reversePairs(int[] nums){
    int[] temp = new int[nums.length];
    mergerSort(nums, 0, nums.length - 1, temp);
    return count;
  }
  
  private void mergerSort(int[] nums, int low, int high, int[] temp){
    if (low < high){
      int mid = low + ( high - low ) / 2;
      mergerSort(nums, low, mid, temp);
      mergerSort(nums, mid + 1, high, temp);
      merge(nums, low, mid, high, temp);
    }
  }
  
  private void merge(int[] nums, int low, int mid, int high, int[] temp){
    int i = low;
    int j = mid + 1;
    int t = 0;
    while (i <= mid && j <= high){
      if (nums[i] <= nums[j]){
        temp[t++] = nums[i++];
      }else{
        count += (mid - i + 1);
        temp[t++] = nums[j++];
      }
    }
    while (i <= mid){
      temp[t++] = nums[i++];
    }
    while (j <= high){
      temp[t++] = nums[j++];
    }
    t = 0;
    while (low <= high){
      nums[low++] = temp[t++];
    }
  }
}
```
