# 操作系统

### 原码、反码、补码

**原码**：就是符号位加真值的绝对值。

```
[+1]原 = 0000 0001

[-1]原 = 1000 0001
```

**反码**：正数的反码是其本身，负数的反码是“符号位不变，其余各位取反”

```
[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反
```

**补码**：正数的补码是其本身，负数的补码是“反码的基础上 +1 ”

```
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

机器使用补码表示数据，所以编程中常使用的 32位 int 类型，可以表示的范围是：[-2^31, 2^31 - 1]，因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值。



### 内核态和用户态：

用户态和内核态最大的区别就是他们的权限不同。**内核态下**：CPU 可以访问内存的所有数据，包括外围设备，比如硬盘，网卡等。CPU 也可以将自己从一个程序切换到另外一个程序。**用户态下**：只能访问受限等内存，不允许访问外围设备。

#### 为什么要区分用户态和内核态？

主要是实现资源隔离和通过系统调用接口提供硬件资源。在 CPU 的所有指令中，有一些指令是非常危险的，如果错用，就会导致整个系统的奔溃。比如：清理内存，设置时钟等。如果所有的程序都能够使用这些危险的指令，那么操作系统一天奔溃很多次都很正常。所以，CPU 将指令分为特权指令和非特权指令，只有内核态下才能执行特权指令。对于那些危险的指令，只允许操作系统及其相关模块使用。

### 进程和线程的区别？

**进程**：进程是程序的一次执行过程，是程序在执行过程中的分配和管理资源的基本单位，进程之间相互独立，每个进程都有自己的地址空间。一个进程在执行中可能产生许多个线程。

**线程**：线程是 CPU 调度和分配的基本单位，它可以和同一进程下的其他线程共享资源。同一进程的线程会相互影响，线程开销小，不利于资源管理和保护。

进程的五种状态：创建、就绪、运行、阻塞、结束

线程的六种状态：初始、运行、阻塞、等待、超时等待、终止

### Java 线程状态

定义在 Thread 类中的 State 枚举。

**NEW**：创建后但为启动（没有被 start 启动）

**RUNNABLE**：线程可能正在运行，或者可能正在等待系统资源（如 CPU 时间片，如等待网络 IO 读取数据）。

**BLOCKED**：阻塞状态，原因通常是在等待一个锁，当尝试进入一个 synchronized 语句块 / 方法时，锁已被其他线程占有就会被阻塞。
**WAITING**：无限期等待，这种状态的线程不会被分配 CPU 时间片，他们要等待显示的被其他线程唤醒。导致 WAITING 状态的有：Object.wait(), Thread.join(), LockSupport.park(). 需要用 Object.notify(), Object.notifyAll() 来唤醒。

**TIMED_WAITING**：（限期等待）。这种状态的线程不会被分配 CPU 时间片，但无需其他线程显示唤醒，在一定时间后会由系统自动唤醒。导致 TIMED_WAITING 的有：Thread.sleep()，带 timeout 的 Object.wait() 或 Thread.join()， LockSupport.parkNanos() 方法，LockSupport.parkUntil() 方法。

**TERMINATED**：线程已经结束执行。

### 僵尸进程和孤儿进程

僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然存在系统中。这种进程称之为僵尸进程。

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将会成为孤儿进程。孤儿进程将 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

**问题和危害**：一个进程成为孤儿进程后，其善后回收工作的重任就到了 init 进程的头上。而 init 进程能够完成对孤儿进程状态收集和回收工作，所以不会有什么问题。 话说回来，如果进程不调用 wait / waitpid 的话，那么保留的那段进程信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，**如果大量的产生僵尸进程，将会因为没有可用的进程号而导致系统不能产生新的进程。**

### 进程间通信的方式（IPC）

1.管道， 2. 匿名管道， 3. 信号， 4. 信号量， 5. 消息队列， 6. 套接字， 7. 共享内存

### 匿名管道和有名管道的区别：

1. 匿名管道只能用于具有亲缘关系的两个进程间的通信，有名管道可以用于任何两个进程间的通信，要灵活方便很多。
2. 有名管道是一种特殊的文件类型，而且存在于文件系统中。所以，当通信进程使用完有名管道后，如果没有对其进行删除，该文件将依然存在。而匿名管道只存在于内存中，无法在文件系统中存在。

### 线程同步的方式：

信号量，互斥量，事件（wait / notify）

### 进程调度算法

1.先来先服务 2.最短作业优先 3.高响应比优先（响应比 = （作业处理时间 + 要求服务时间）/ 要求服务时间）4.时间片轮转 5.高优先级 6.多级反馈队列

### 页面置换算法

1.最佳页面置换（置换在“未来”最长时间不访问的页面）2.先进先出置换 3.最近最久未使用置换（选择最长时间没有被访问的页面进行置换）4.时钟页面 5.最不常用置换（淘汰一定时期内访问次数最少的）

### 磁盘调度算法

1.先来先服务算法 2.最短寻址时间优先 3.扫描算法 4.循环算法

### 对称加密和非对称加密

对称加密：加解密使用同一串密钥，只有一个密钥称为私钥，常见 DES， AES

非对称加密：加解密使用不同对密钥，一公钥，一私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。 常见 RSA

**对称加密优缺点**：加解密效率高，加密速度快。但是密钥分发和管理困难，不是很安全，密钥管理负担严重。

**非对称加密优缺点**：安全性高，公钥是公开的，私钥自己保存。缺点：加解密时间长，速度慢，只适合少量数据进行加密。

补充：**消息摘要**：将消息哈希成一个长度固定的唯一值，该过程不可逆。常见 MD5，SHA256

### 负载均衡

负载均衡用来在多个计算机、网络连接、CPU、磁盘或其他资源中分配负载，以达到优化资源使用，最大化吞吐率，最小响应时间，同时避免过载的目的。

负载均衡的方法：1.轮询 2.加权轮询 3.随机 4.源地址散列 5.最小连接数



### 什么是 IO 多路复用：

- IO 多路复用是一种同步 IO 模型，实现一个线程可以监视多个文件句柄。

- 一旦某个文件句柄就绪，就能通知应用程序进行相应的读写操作。

- 没有文件句柄就绪，就会阻塞应用程序，交出 CPU。



### select poll epoll 之间的区别：

select，poll 和 epoll 都是 I/O多路复用的机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者是写就绪），能够通知程序进行相应的读写操作。

select 和 poll 本质上没有什么区别，它们仅仅能知道有 I/O 事件发生了，但是并不知道具体是哪几个流。所以只能通过无差别的轮询所有的流，找出能读数据或是写入数据的流，并对这些流进行操作。所以 select 和 poll 的时间复杂度为 O(n) 。不过 select 有能监视的最大连接数的限制，而 poll 没有（基于链表实现）。

epoll 可以理解成是**事件驱动型的 poll**，每个事件都会关联上 fd （文件描述符），这使得不必通过轮询的方式，epoll 也能够把哪个流发生了怎样的 I/O 事件通知给我们，这样做使得时间复杂度降到了 O(1)。

epoll 底层维护了 eventpoll 结构体，该结构体包含 1.就绪队列，用来存放已经就绪的文件描述符 2.红黑树，用来收集文件描述符。 所有添加到 epoll 中的事件都会与驱动程序建立回调关系，当相应的事件发生时，会通过回调的方式，将就绪的事件添加到就绪队列中去。

总结：1.实现方式（轮询，事件驱动）2.最大连接数 3.fd剧增后带来的 IO 效率问题。 4.消息传递方式（select poll ：内核需要将消息传递到用户空间，都需要内核拷贝动作， epoll 通过内核和用户空间共享一块内存实现）

### 死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求并保持：一个进程因请求资源而阻塞时，对已经获得的资源保持不释放。
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源的关系。

### 处理死锁的方法

1. 预防死锁和避免死锁：针对产生死锁的四个条件，提前设置某些限制条件。
2. 检测死锁：通过某种检测机制，及时检测出死锁的发生，以便后续采取措施。
3. 解除死锁：当检测到系统中已发生死锁时，就采取相应的措施，把进程从死锁中解脱出来。