# 数据库

### 数据库设置冗余字段：

数据库设置冗余字段：对于不会频繁更改，但会频繁查询的字段可以设置冗余。

例子：有学生表 student(id, sno, name, major_id) 和 专业信息表 major(id, major_name)。现有如下查询：select s.id, sno, name, major_name from student as s join major as m on s.major_id = m.id;

可以看到为了查到 major_id 对应的专业名称，需要将两张表连接。这时候可以设计冗余，使得学生表变为 student(id, sno, name, major_id, major_name)



### 数据库的三范式：

**第一范式**：必须不包含重复组的关系，即每一列都是不可拆分的原子项。

<img src="/Users/paranoid/Library/Application Support/typora-user-images/image-20210516232740073.png" alt="image-20210516232740073" style="zoom:50%;" />

**第二范式**：首先满足第一范式的条件，并且所有非主属性都完全依赖于主属性。**符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。**

举例如关系表：（职工号，姓名，职称，项目号，项目名称）中，职工号->姓名，职工号->职称，而项目号->项目名称。显然依赖关系不满足第二范式，常用的解决办法是拆分表格，比如拆分为职工信息表和项目信息表。

**第三范式**：首先满足第二范式的条件，并且所有非主属性对任何候选关键字不存在传递依赖。即每个属性跟主键有直接关系而不是间接关系，像 a --> b --> c 这种就是间接关系。

比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)。我们应该拆开来，如下：

（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）



### MyISAM 和 InnoDB 的区别：

MyISAM 性能不错，而且提供了例如全文索引，压缩，空间函数这样的特性。但是它不支持事务和行级锁，最大缺陷是奔溃后无法安全恢复。

|                | MyISAM | InnoDB                                                       |
| -------------- | ------ | ------------------------------------------------------------ |
| 锁             | 表级   | 行级 + 表级                                                  |
| 事务和奔溃恢复 | 不支持 | 提供事务和外键，具有事务、回滚和奔溃恢复的能力               |
| MVCC           | 不支持 | 应对高并发事务，MVCC比单纯加锁更加有效。MVCC仅在读已提交和可重复读两个隔离级别下工作。 |



### MySQL 选择 B+ 树做索引的原因？

...



### 事务的四大特性？ ACID

原子性：事务是最小的执行单位，不允许分割。确保动作要么全完成，要么全不起作用。

一致性：执行事务前后，数据保持一致，多个事务对同一数据的读取结果应该相同。

隔离性：并发访问数据库时，一个事务的执行不能被其他事务干扰。

持久性：一个事务提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该有影响。



### MySQL 事务的实现：

**原子性的实现**：要保证原子性就需要在异常发生时，对已经执行的操作进行回滚。 MySQL 的恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再对数据库中对应行写入。

**持久性的实现**：使用重做日志（redo log）实现。重做日志包含两部分，一是内存中的重做日志缓冲区，二是磁盘上的重做日志文件。当一个事务尝试对数据进行修改时：1.会先将数据从磁盘读入内存，并更新内存中缓存的数据。2.然后生成一条重做日志写入重做日志缓存。3.事务真正提交时，MySQL 将重做日志缓存中内容刷新到重做日志文件中，再将内存中的数据更新到磁盘。

发生错误，在数据库重启时，会从重做日志中找出未被更新的日志重新执行以满足持久性。

**一致性的实现**：保证原子性，隔离性，持久性才能做到事务的一致性。



### 并发事务带来的问题：

**脏读**：一事务访问数据且修改但为提交，二事务读取未修改的数据，这就是脏读（依据脏读数据做的操作可能不正确）。

**丢失修改**：一事务读取，二事务读取，此时两事务读取到的值应当相同。一事务修改，二事务再修改。这样就丢失了一事务的修改。

**不可重复读**：一事务读取，二事务读取并修改，一事务读取。这样事务一两次读取到的数据不一样。

**幻读**：一事务读取几行数据，二事务插入数据，一事务再次读取发现多出了几行数据。



### 四个隔离级别：

|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | √    | √          | √    |
| 读已提交 | X    | √          | √    |
| 可重复读 | X    | X          | √    |
| 串行化   | X    | X          | X    |



### MySQL 中的锁：

**行级锁**：MySQL 中粒度最小的锁，只针对当前操作的行加锁。行级锁能大大减少数据库操作的冲突。加锁粒度小，并发度高，加锁开销大，加锁慢。

**表级锁**：MySQL 中粒度最大的锁，针对当前操作的表进行加锁。实现简单，资源消耗少，加锁快。加锁粒度大，触发锁冲突概率高，并发度最低。



### 通过 MySQL 的事务和锁防止超卖

基于 MySQL 的事务和锁实现方式：

1. 开启事务
2. 查询库存，并显示的设置写锁（排他锁）：SELECT * FROM table_name WHERE ... FOR UPDATE
3. 生成订单
4. 去库存，隐示的设置写锁（排他锁）：UPDATE goods SET counts = counts - 1 WHERE id = ? 
5. commit，释放锁

如果不开启事务，第 2 步即使加锁，第一个会话读取库存结束后，就会释放锁，第二个会话仍有机会在去库存前读库存，出现超卖。

如果开启事务，第 2 步不加锁，第一个会话读库存结束后，第二个会话可能出现 `脏读`，出现超卖。

既加事务，又加读锁：开启事务，第一个会话读库存时加读锁，并发时，第二个会话也允许获得读库存的读锁，但是第一个会话执行写操作时，写操作会等待第二个会话的读锁，第二个会话执行写操作时，操作也会等待第一个会话的读锁，会出现死锁。

既加事务，又加写锁：第一个会话读库存时加写锁。写锁会阻止其他事务的读锁和写锁。直到 commit 才会释放，此时才允许第二个会话查询库存，不会出现超卖现象。

Notice ：在事务中，锁只有在执行 commit 或者 rollback 的时候才会释放， 并且所有的锁都在**同一时刻**释放。



### 使用 MySQL 实现的乐观锁：

一般有两种方式：

1. 使用数据版本（version）记录机制实现，即为数据增加一个版本表示（就是在数据表中增加一个数字类型的 version 字段）。当读取数据的时候，将 version 字段一同读出，数据每更新一次，就对 version 值加一。当提交更新的时候，判断数据表对应记录的当前版本信息和第一次取出来的 version 值进行比对，如果两者相同，则予以更新。不同的话，则认为是过期数据，放弃更改。
2. 其实和第一种实现方式差不多，同样是在数据表中添加一个字段，名称无所谓，字段类型使用**时间戳**。实现方式和第一种相同。

利用 MySQL 实现的乐观锁，实现下单的操作：

1. 查询商品信息： 

   ```mysql
   SELECT (status, stock_count, version) FROM goods WHERE id = #{id}
   ```

2. 根据商品信息生成订单

3. 修改商品 status 为 2：

   ```mysql
   UPDATE goods SET status = 2, version = version + 1
   WHERE id = #{id} AND  version = #{version}
   ```

如果上面的更新操作失败了，则放弃生成的订单。



### 聚簇索引和非聚簇索引

**聚簇索引**：将数据存储与索引放到一起，找到索引也就找到了数据。（一张表只允许有一个）

**非聚簇索引**：将数据与索引分开，索引的叶子节点指向了数据的对应行。在访问数据时要先搜索索引，在通过索引在磁盘中找到相应的数据。



### 哪些字段适合建立索引：

1. 表的主键，外键必须有索引。
2. 经常与其他表进行连接的表，在连接字段上应该有索引。
3. 经常出现在 where 子句中的字段。
4. 查询频率高的字段。
5. 尽量使用单字段索引。
6. 应该选择小字段。大的文本字段，超长字段不要建立索引。



### 什么是最左匹配原则？

在 MySQL 建立联合索引时会遵循最左匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。对于 建立 (a, b, c) 这样的联合索引，实际上产生了 a 索引， a, b 索引， a, b, c 索引。



### 索引失效的情况：

1. 违反了最左匹配原则。
2. 在索引列上用了函数或手动进行了类型转换。
3. 使用了 !=, < , > 
4. like 后以通配符开头 （ %abc ）



### 索引的优点和缺点

索引的优点主要体现在以下几个方面：

1. 索引可以减少服务器需要扫描的数据量，从而大大提高查询的效率。
2. 唯一索引能保证表中数据的唯一性。
3. 利用索引对数据存储的特性，可以使查询语句避免排序和创建临时表。
4. 加速表与表之间的连接速度。
5. 显著减少查询中分组和排序的时间。

索引的缺点主要体现在以下几个方面：

1. 索引的创建和维护，需要时间，并且数据量越大时间越长，这会造成工作量的增加。
2. 索引会造成数据量大增加，除了数据表中数据占据空间外，每一个索引还需要占一定的物理空间。
3. 对表中的数据进行增加，修改，删除的时候，索引也要同时进行维护，降低了数据的维护速度。



### MySQL 中的索引类型

...



### MySQL 中的索引：

1. 普通索引：最基本的索引，没有任何限制，仅用来加速查询。
2. 唯一索引：在普通索引的基础上，加上索引列的值必须唯一的限制（但是允许空值），如果是组合索引的话，则列值的组合必须唯一。
3. 主键索引：一种特殊的唯一索引，一个表只能有一个主键，主键不允许有空值，一个表也只能有一个主键索引。
4. 组合索引：在多个字段上创建的索引，只有在查询条件中使用了组合索引的第一个字段，索引才会被使用。使用组合索引遵循最左前缀原则。
5. 全文索引：只能在 char，varchar，text 列上创建全文索引。全文索引主要用来查找文本中的关键字，并且这种方式实现的查询过滤比使用 like + % 快 N 倍。

ps.

覆盖索引： SELECT 后的数据列只用在索引中就能全部获得，所以不必读取数据行。换句话说，就是查询的列要被索引覆盖。

 

### Redis 一般用来做什么：

Redis 是内存高速缓存数据库，在服务器中常用来存储需要频繁调取的数据，这样可以大大节省系统直接读取磁盘数据的 IO 开销，更重要的是可以极大提升速度。

比如某网站一天有 100 万人访问，其中某个板块需要从数据库查询，那么一天就要多消耗 100 万次数据库请求。这种情况我们可以把热点数据存到 Redis 中，需要的时候，直接从内存中获取，极大的提高了速度，节省服务器开销。



### Redis 中的五种基本数据结构

Redis 中有五种基础数据结构，分别是：string（字符串），list（列表），hash（字典），set（集合），zset（有序集合）。





### Redis 持久化机制

Redis 支持持久化，并且有两种方式实现持久化：一种是快照，一种是只追加文件。

**快照（RDB快照）**：通过创建快照来获得存储在内存里的数据在某个时间点的副本。

**只追加文件（AOF）**：每执行一条会更改 Redis 中数据的命令， Redis 都会把该命令写入硬盘中的 AOF 文件。



### 缓存穿透、缓存雪崩、缓存击穿

**缓存穿透**：大量请求缓存和数据库中没有的数据。

解决方案：1.做好参数校验，不合法的参数请求直接抛出异常信息，返回客户端。2.布隆过滤器

**缓存雪崩**：缓存在同一时间大面积失效，导致之后的请求全部落在数据库上。

解决方案：1.采用 Redis 集群，避免单机出现问题，整个缓存服务都失效。2.限流，避免同时处理大量的请求。3.批量向 Redis 中存储数据的时候，把每个 Key 的失效时间都加上一个随机值。

**缓存击穿**：某个 Key 非常热点，大并发集中对这个点进行访问，当这个点的缓存失效，大量请求落在数据库。

解决方案：设置热点数据永不过期。



### Redis 分布式寻址算法：

1. Hash 算法 （问题：大量缓存重建，缓存雪崩）

   来一个 Key，首先计算 Hash 值，然后对节点数进行取模。然后加载到不同的 master 节点上。一旦某个 master 节点宕机，之后的请求，都会根据剩余 master 节点数去取模，尝试去取数据。 这会导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库。

2. 一致性 Hash 算法

   **优点**：可扩展性，一致性 Hash 算法保证了增加或减少服务器时，数据存储的改变量最少，相比传统 Hash 算法大大节省了数据移动的开销。

   **一致性 Hash 算法与 Hash 算法的关系**：一致性 Hash 算法是在 Hash 算法基础上提出的，在动态变化的分布式环境中，Hash 算法应该满足的几个条件：平衡性、单调性和分散性。

   平衡性：是指Hash的结果应该平均分配到各个节点，这样从算法上解决了负载均衡的问题。

   单调性：是指在新增或者删除节点时，不影响系统的正常运行。

   分散性：是指数据应该分散地存放在分布式集群中的各个节点（节点自己可以有备份），不必每个节点都存储所有数据。

   一致性 Hash 算法将整个 Hash 值空间组织成一个虚拟的圆环，整个空间按照顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 Hash. 这样就能确定每个节点在哈西环上的位置。

   来一个 Key，首先计算 Hash 值，并确定此数据在环上的位置，从此位置沿顺时针行走，遇到的第一个 master 节点就是 key 所在的位置。

   在一致性 Hash 算法中，如果一个节点挂了，受影响的数据仅仅是从此节点到环空间前一个节点（沿着环逆时针方向遇到的第一个节点）之间的数据，其他不受影响。增加一个节点同理。

   但是一致性 Hash 算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。为了解决缓存热点的问题，一致性 Hash 算法引入了虚拟节点机制。即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到 Hash 环上，如果要确定对象的服务器，需要先确定对象所在的虚拟服务器，再由虚拟服务器确定物理服务器。

   <img src="/Users/paranoid/Library/Application Support/typora-user-images/image-20210515171539693.png" alt="image-20210515171539693" style="zoom:50%;" />

3. Hash Slot 算法

   Redis Cluster 有固定的 16384 个 Hash Slot，对每个 Key 计算 CRC16 值，然后对 16384 取模，可以获取 Key 对应的 Hash Slot。

   每个服务器节点可以负责维护一部分 Slot 以及 Slot 所映射的键值数据。

   这样的结构很容易添加或者是删除节点，如果增加一个节点 6 ，就需要从节点 1-5 获得部分 Slot 分配到节点 6 上。如果想移除节点 1，需要将节点 1 中的 Slot 移到节点 2-5 上，然后将没有任何 Slot 的节点1 从集群中删除即可。

   **缓存 Key 的 Hash 结果是和 Slot 绑定的，而不是和服务器节点绑定的，所以节点的更替只需要迁移 Slot 即可平滑过度。**